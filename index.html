<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini English Tutor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Identity Services (GSI) Client -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Babel for in-browser transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.1.0",
    "react-dom/client": "https://esm.sh/react-dom@^19.1.0/client",
    "@google/genai": "https://esm.sh/@google/genai@^1.8.0",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "react/": "https://esm.sh/react@^19.1.0/"
  }
}
</script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-gray-950 text-white font-sans">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
import React, { useState, useCallback, useEffect, useRef } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI } from "@google/genai";

// ==========================================================================================
// All types, constants, components, and services are consolidated in this file.
// ==========================================================================================

// --- From types.ts ---
var CEFRLevel;
(function (CEFRLevel) {
    CEFRLevel["A1"] = "A1 (Beginner)";
    CEFRLevel["A2"] = "A2 (Elementary)";
    CEFRLevel["B1"] = "B1 (Intermediate)";
    CEFRLevel["B2"] = "B2 (Upper-Intermediate)";
    CEFRLevel["C1"] = "C1 (Advanced)";
})(CEFRLevel || (CEFRLevel = {}));

var AppState;
(function (AppState) {
    AppState[AppState["AUTH"] = 0] = "AUTH";
    AppState[AppState["AUTH_LOADING"] = 1] = "AUTH_LOADING";
    AppState[AppState["WELCOME"] = 2] = "WELCOME";
    AppState[AppState["ASSESSING"] = 3] = "ASSESSING";
    AppState[AppState["ASSESSMENT_LOADING"] = 4] = "ASSESSMENT_LOADING";
    AppState[AppState["RESULTS"] = 5] = "RESULTS";
    AppState[AppState["LEARNING"] = 6] = "LEARNING";
    AppState[AppState["LEVEL_UP_ASSESSMENT_LOADING"] = 7] = "LEVEL_UP_ASSESSMENT_LOADING";
    AppState[AppState["LEVEL_UP_ASSESSING"] = 8] = "LEVEL_UP_ASSESSING";
    AppState[AppState["LEVEL_UP_RESULTS"] = 9] = "LEVEL_UP_RESULTS";
})(AppState || (AppState = {}));


// --- From constants.ts ---
const GOOGLE_CLIENT_ID = "964856571599-1v6c6scu4l8leeoferjfhhrn0ftt4t3j.apps.googleusercontent.com";

const DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
const DRIVE_APP_FILE_NAME = 'gemini-english-tutor-data.json';

const CEFR_LEVELS_ORDER = [
    CEFRLevel.A1,
    CEFRLevel.A2,
    CEFRLevel.B1,
    CEFRLevel.B2,
    CEFRLevel.C1,
];
const PROGRESS_HISTORY_LENGTH = 100;
const PROGRESS_UNLOCK_THRESHOLD = 80;
const LEVEL_UP_TEST_QUESTIONS = 50;
const LEVEL_UP_PASS_PERCENTAGE = 0.8;
const VOCABULARY_MASTERY_THRESHOLD = 15;
const SHORT_TERM_TASK_TYPES_TO_TRACK = 5;
const LONG_TERM_TASK_HISTORY_LENGTH = 30;
const CONCURRENT_WORDS_TO_LEARN = 20;
const MISTAKES_TO_REMEMBER = 5;
const RECENT_WORDS_TO_TRACK = 5;

// --- Utility Functions ---
const shuffleArray = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
};

const debounce = (func, waitFor) => {
    let timeout = null;
    return (...args) => {
        if (timeout !== null) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => func(...args), waitFor);
    };
};


// --- Icon Components ---
const CheckCircleIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-6 h-6 text-green-400">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z" clipRule="evenodd" />
    </svg>
);

const XCircleIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-6 h-6 text-red-400">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z" clipRule="evenodd" />
    </svg>
);

const SpeakerWaveIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5">
      <path d="M13.5 4.06c0-1.336-1.616-2.005-2.56-1.06l-4.5 4.5H4.508c-1.141 0-2.318.664-2.66 1.905A9.76 9.76 0 0 0 1.5 12c0 1.598.378 3.11.992 4.495 1.036 3.163 4.257 4.255 6.875 2.48l.523-.349.523.349a11.232 11.232 0 0 0 8.351 1.09c.421-.129.73-.503.73-.949V5.12c0-.446-.309-.82-.73-.949a11.23 11.23 0 0 0-8.351-1.09l-.523.349-.523-.349Z" />
    </svg>
);

const BookOpenIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6-2.292m0 0v14.25" />
    </svg>
);

const GoogleIcon = () => (
    <svg className="w-5 h-5" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"/>
      <path fill="#FF3D00" d="M6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"/>
      <path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.223 0-9.641-3.251-11.303-7.583l-6.522 5.025C9.505 39.556 16.227 44 24 44z"/>
      <path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.16-4.082 5.574l6.19 5.238C42.099 34.909 44 30.016 44 24c0-1.341-.138-2.65-.389-3.917z"/>
    </svg>
);


// --- TTS Service ---
let voices = [];
const populateVoices = () => {
    if (typeof window !== 'undefined' && window.speechSynthesis) {
        voices = window.speechSynthesis.getVoices();
    }
};

populateVoices();
if (typeof window !== 'undefined' && window.speechSynthesis && window.speechSynthesis.onvoiceschanged !== undefined) {
    window.speechSynthesis.onvoiceschanged = populateVoices;
}

const speakText = (text) => {
    if (!text || typeof window === 'undefined' || !window.speechSynthesis) return;

    window.speechSynthesis.cancel();
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    const preferredVoiceNames = [
        "Google US English",
        "Samantha", // Apple
        "Microsoft Zira Desktop - English (United States)", // Windows
    ];
    let selectedVoice = voices.find(v => preferredVoiceNames.includes(v.name) && v.lang.startsWith('en'));
    
    if (!selectedVoice) {
        selectedVoice = voices.find(v => v.lang.startsWith('en-US') && v.name.toLowerCase().includes('female'));
    }
    if (!selectedVoice) {
        selectedVoice = voices.find(v => v.lang.startsWith('en-US'));
    }
    
    if (selectedVoice) {
        utterance.voice = selectedVoice;
    }

    utterance.lang = 'en-US';
    utterance.rate = 0.95;
    utterance.pitch = 1.1;

    window.speechSynthesis.speak(utterance);
};


const SpeakButton = ({ text, className = '' }) => {
    if (typeof window === 'undefined' || !window.speechSynthesis) return null;

    const handleSpeak = (e) => {
        e.preventDefault();
        e.stopPropagation();
        speakText(text);
    };

    return (
        <button
            onClick={handleSpeak}
            className={`text-slate-400 hover:text-purple-400 transition-colors shrink-0 ${className}`}
            aria-label={`Произнести текст`}
            title="Произнести текст"
        >
            <SpeakerWaveIcon />
        </button>
    );
};

// --- From components/common/Card.tsx ---
const Card = ({ children, className = '', ...props }) => {
    return (
        <div 
            className={`bg-slate-800/40 backdrop-blur-xl border border-slate-700/50 rounded-2xl shadow-2xl shadow-black/40 p-6 sm:p-8 ${className}`}
            {...props}
        >
            {children}
        </div>
    );
};

// --- From components/common/Button.tsx ---
const Button = ({ children, variant = 'primary', isLoading = false, className = '', icon, ...props }) => {
    const baseClasses = "font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-4 focus:ring-opacity-50 transition-all duration-300 ease-in-out inline-flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed text-base transform hover:scale-[1.03] disabled:hover:scale-100";
    const variantClasses = {
        primary: "bg-purple-600 hover:bg-purple-700 focus:ring-purple-400 text-white shadow-lg shadow-purple-600/20",
        secondary: "bg-slate-600 hover:bg-slate-700 focus:ring-slate-500 text-white",
        ghost: "bg-transparent hover:bg-slate-700/50 focus:ring-slate-500 text-slate-300",
        google: "bg-white hover:bg-slate-200 focus:ring-blue-500 text-slate-800 border border-slate-300",
    };
    return (
        <button className={`${baseClasses} ${variantClasses[variant]} ${className}`} disabled={isLoading || props.disabled} {...props}>
            {isLoading ? (
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            ) : (
                <>{icon && <span className="mr-2 -ml-1">{icon}</span>}{children}</>
            )}
        </button>
    );
};

// --- From components/common/Loader.tsx ---
const Loader = ({ text }) => {
    return (
        <div className="flex flex-col items-center justify-center text-center p-8">
            <svg className="animate-spin h-12 w-12 text-purple-500 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p className="text-xl font-semibold text-slate-300">{text}</p>
        </div>
    );
};

// --- From services/geminiService.ts ---
class GeminiService {
    ai;

    constructor(apiKey) {
        if (!apiKey) throw new Error("API key is required to initialize GeminiService.");
        this.ai = new GoogleGenAI({ apiKey: apiKey });
    }

    async testConnection() {
        try {
            const response = await this.ai.models.generateContent({
                model: "gemini-2.5-flash",
                contents: "test",
                config: { thinkingConfig: { thinkingBudget: 0 } }
            });
            return { success: !!response?.text };
        } catch (error) {
            console.error("API Connection Test Failed:", error);
            const errorText = (error.message || '').toLowerCase();
            let errorMessage = "Проверьте ваш Gemini API ключ и его ограничения.";
            if (errorText.includes('api key not valid')) {
                errorMessage = "Gemini API ключ недействителен. Пожалуйста, проверьте его.";
            } else if (errorText.includes('quota') || errorText.includes('billing') || errorText.includes('rate limit')) {
                errorMessage = "Достигнут лимит использования Gemini API. Пожалуйста, проверьте лимиты в Google AI Studio или привяжите платежный аккаунт.";
            } else if (errorText.includes('fetch')) {
                 errorMessage = "Ошибка сети при подключении к Gemini. Проверьте ваше интернет-соединение.";
            }
            return { success: false, error: errorMessage };
        }
    }

    parseJsonResponse = (text) => {
        let jsonStr = text.trim();
        const fenceRegex = /^```(\w*)?\s*\n?(.*?)\n?\s*```$/s;
        const match = jsonStr.match(fenceRegex);
        if (match && match[2]) jsonStr = match[2].trim();
        try {
            return JSON.parse(jsonStr);
        } catch (e) {
            console.error("Failed to parse JSON response:", e, "Raw text:", text);
            return null;
        }
    };

    async generateAssessmentTest() {
        const prompt = `
        Create a 30-question English proficiency test to accurately determine a user's CEFR level.
        The test must be comprehensive and include a balanced distribution of questions across levels A1 to B2.
        - 6 questions for A1 level
        - 7 questions for A2 level
        - 9 questions for B1 level
        - 8 questions for B2 level
        For each question, provide a clear question, 4 multiple-choice options, and the correct answer.
        The 'level' field must be one of: "A1 (Beginner)", "A2 (Elementary)", "B1 (Intermediate)", "B2 (Upper-Intermediate)".
        Return the result as a JSON array of objects. Each object must have this exact structure:
        { "question": "string", "options": ["string", "string", "string", "string"], "correctAnswer": "string", "level": "CEFRLevel" }
        IMPORTANT: Your entire response must be ONLY the valid JSON array, with no other text, explanations, or markdown fences. The JSON MUST be perfect and parsable. Do not include a trailing comma after the last object in the array.
        `;
        try {
            const response = await this.ai.models.generateContent({ model: "gemini-2.5-flash", contents: prompt, config: { responseMimeType: "application/json", temperature: 0.3 } });
            const questions = this.parseJsonResponse(response.text);
            if (!questions || !Array.isArray(questions) || questions.length < 30) throw new Error("Could not generate a valid assessment test.");
            
            questions.forEach(q => {
                if (q.options && Array.isArray(q.options)) {
                    shuffleArray(q.options);
                }
            });
            
            return questions;
        } catch (error) {
            console.error("Error generating assessment test:", error);
            throw new Error("Failed to communicate with the AI. Please check your connection and API key.");
        }
    }

    async generateLevelUpTest(level) {
        const prompt = `
        Create a challenging ${LEVEL_UP_TEST_QUESTIONS}-question English proficiency test to confirm a user's mastery of the ${level} CEFR level.
        This test is for a user who is currently at the ${level} level and wants to prove they have mastered it before advancing.
        The questions must be difficult and cover a wide range of grammar, vocabulary, and reading comprehension topics appropriate for the ${level} level.
        For each question, provide a clear question, 4 multiple-choice options, the correct answer, and the 'level' field for all questions MUST be exactly "${level}".
        Return the result as a JSON array of objects. Each object must have this exact structure:
        { "question": "string", "options": ["string", "string", "string", "string"], "correctAnswer": "string", "level": "${level}" }
        IMPORTANT: Your entire response must be ONLY the valid JSON array.`;
        try {
             const response = await this.ai.models.generateContent({ model: "gemini-2.5-flash", contents: prompt, config: { responseMimeType: "application/json", temperature: 0.2 } });
            const questions = this.parseJsonResponse(response.text);
            if (!questions || !Array.isArray(questions) || questions.length < LEVEL_UP_TEST_QUESTIONS) throw new Error("Could not generate a valid level-up test.");
            
            const finalQuestions = questions.slice(0, LEVEL_UP_TEST_QUESTIONS);
            finalQuestions.forEach(q => {
                if (q.options && Array.isArray(q.options)) {
                    shuffleArray(q.options);
                }
            });

            return finalQuestions;
        } catch (error) {
            console.error(`Error generating level-up test for ${level}:`, error);
            throw new Error("Не удалось сгенерировать тест. AI вернул некорректные данные. Попробуйте еще раз.");
        }
    }

    async generateLearningTask(level, feedbackHistory, isPreLevelUp, globalInstructions, vocabularyProgress, recentMistakes, shortTermTaskTypeHistory = [], fullTaskTypeHistory = [], recentWordsPracticed = []) {
        const ALL_TASK_TYPES = ['reading', 'grammar', 'vocabulary', 'fill-in-the-blanks', 'sentence-construction', 'error-correction', 'role-play', 'word-formation', 'translation-choice', 'spelling-choice', 'synonym-antonym-quiz', 'definition-matching', 'odd-one-out', 'categorization'];
        
        const masteredWords = Object.entries(vocabularyProgress)
            .filter(([, count]) => count >= VOCABULARY_MASTERY_THRESHOLD)
            .map(([word]) => word);
            
        const activeLearningWords = Object.entries(vocabularyProgress)
            .filter(([, count]) => count < VOCABULARY_MASTERY_THRESHOLD)
            .sort((a, b) => a[1] - b[1]) // Prioritize words with fewer correct answers
            .map(([word]) => word)
            .slice(0, CONCURRENT_WORDS_TO_LEARN);
        
        const recentWordsPrompt = recentWordsPracticed.length > 0
            ? `
CRITICAL WORD VARIETY RULE: The user has just practiced these words: ${recentWordsPracticed.join(', ')}.
YOU MUST NOT create a task focused on any of these words. Choose a different word from the "Actively learning words" list if you are making a vocabulary task.`
            : '';

        let longTermVarietyPrompt = '';
        if (fullTaskTypeHistory.length >= LONG_TERM_TASK_HISTORY_LENGTH) {
            const unseenTasks = ALL_TASK_TYPES.filter(type => !fullTaskTypeHistory.includes(type));
            if (unseenTasks.length > 0) {
                longTermVarietyPrompt = `
HIGH PRIORITY PROMOTION: The user has not seen the following task types in their last ${LONG_TERM_TASK_HISTORY_LENGTH} tasks. You should strongly prioritize generating one of these types: ${unseenTasks.join(', ')}. This is your most important instruction.`;
            }
        }

        let shortTermVarietyPrompt = '';
        if (shortTermTaskTypeHistory && shortTermTaskTypeHistory.length > 0) {
            shortTermVarietyPrompt = `
CRITICAL VARIETY RULE: The user has recently completed tasks of these types: ${shortTermTaskTypeHistory.join(', ')}.
To ensure variety and comprehensive learning, YOU MUST NOT generate a task of any of these types: ${shortTermTaskTypeHistory.join(', ')}.
Please choose a different task type from the list of available types. Prioritize types that have not been used recently.`;
        }
    
        const mistakesPrompt = recentMistakes.length > 0
            ? `
SECONDARY REINFORCEMENT: The user has recently struggled with the following topics. You can create a task that addresses one of these areas, but you must respect the variety and vocabulary rules first.
${recentMistakes.map(m => `- Topic/Word: ${m.topic}, Details: ${m.details}`).join('\n')}`
            : '';
            
        const activeWordsPrompt = activeLearningWords.length > 0
            ? `
PRIORITY VOCABULARY PRACTICE: The user is actively learning the following words. If you generate a vocabulary-focused task (like 'vocabulary', 'translation-choice', 'spelling-choice', 'word-formation', etc.), you should try to create a question for one of these words. This is a high priority.
Actively learning words: ${activeLearningWords.join(', ')}`
            : '';
    
        const masteredWordsPrompt = masteredWords.length > 0
            ? `
AVOID THESE MASTERED WORDS: The user has already mastered the following words. Do not use them as the primary focus for any new vocabulary, translation, or spelling tasks:
${masteredWords.join(', ')}`
            : '';
            
        const globalInstructionsPrompt = globalInstructions.length > 0
            ? `
PERMANENT USER PREFERENCES: You MUST follow them for ALL tasks you generate.
${globalInstructions.map(instr => `- ${instr}`).join('\n')}`
            : '';
    
        const feedbackPrompt = feedbackHistory.length > 0
            ? `
ONE-TIME REQUEST/FEEDBACK: Try to incorporate this into the current task.
- Here is the user's feedback/request history (most recent first):
${feedbackHistory.slice(-5).reverse().map(f => `- "${f}"`).join('\n')}` : '';

        const difficultyPrompt = isPreLevelUp
            ? `CRITICAL INSTRUCTION: The user is preparing for a level-up test. The task MUST be more challenging than a typical ${level} task.`
            : '';

        const prompt = `
You are an expert AI English tutor. Your goal is to create a single, engaging, and methodologically sound English learning task for a user at the ${level} CEFR level.

IMPORTANT GLOBAL CONTEXT: The user is a native Russian speaker. For any 'translation-choice' tasks, the options MUST be in Russian.

Here are your instructions, in order of priority:
1. ${recentWordsPrompt}
2. ${longTermVarietyPrompt}
3. ${shortTermVarietyPrompt}
4. ${activeWordsPrompt}
5. ${masteredWordsPrompt}
6. ${globalInstructionsPrompt}
7. ${difficultyPrompt}
8. ${feedbackPrompt}
9. ${mistakesPrompt}

Choose ONE of the following task types: ${ALL_TASK_TYPES.join(', ')}.
Return the result as a single, perfectly-formed JSON object. Your entire response MUST be ONLY the JSON object, without any surrounding text or markdown fences. The JSON object MUST include a "level": "${level}" field.

Here are the required structures for each type. Follow them strictly.

1.  **Quiz-based Tasks:**
    - **Applies to:** 'reading', 'grammar', 'vocabulary', 'fill-in-the-blanks', 'translation-choice', 'spelling-choice', 'synonym-antonym-quiz', 'definition-matching', 'odd-one-out', 'categorization'.
    - **Base Structure:** { "type": "string", "title": "string", "level": "${level}", "content": "string", "questions": [{ "question": "string", "options": ["string", "string", "string", "string"], "correctAnswer": "string", "wordToLearn": "The specific word being tested, if applicable." }] }
    - **Specific Notes for Quiz types:**
        - **'wordToLearn'**: This field is MANDATORY for 'vocabulary', 'translation-choice', 'spelling-choice', 'synonym-antonym-quiz', 'definition-matching', 'odd-one-out', 'categorization' to track vocabulary progress.
        - **'vocabulary'**: The 'content' should use '___' for the gap. The 'question' asks to fill the blank.
        - **'translation-choice'**: The 'content' should highlight the word to be translated. The 'question' asks for the correct translation.
        - **'spelling-choice'**: The 'question' asks to choose the correct spelling from the options.
        - **'synonym-antonym-quiz'**: The 'question' asks for a synonym or an antonym for a given word in 'content'.
        - **'definition-matching'**: The 'question' asks to match a word from 'content' with its definition in the options.
        - **'odd-one-out'**: The 'content' describes the task (e.g., "Find the word that doesn't belong"). The 'question' presents the group of words. Options should be the words from the group.
        - **'categorization'**: The 'question' asks to which category a given word from 'content' belongs.

2.  **'word-formation' (Interactive Vocabulary Practice):**
    - **Structure:** { "type": "word-formation", "title": "Change the Word Form", "level": "${level}", "content": "A sentence with a word in brackets that needs to be changed. e.g., 'She has a [beauty] voice.'", "baseWord": "The word in brackets, e.g., 'beauty'", "constraints": "The target form of the word, e.g., 'Change the word to an adjective.'", "wordToLearn": "The base word, e.g., 'beauty'" }

3.  **'role-play', 'error-correction', 'sentence-construction':**
    - **role-play**: requires 'context', 'content' (AI's first line), and 'constraints' (user's goal).
    - **error-correction**: requires 'content' (the incorrect sentence).
    - **sentence-construction**: requires 'content' (instructions), 'words' (array of words), and optional 'constraints'.

IMPORTANT: Ensure the generated JSON is valid. Do not add trailing commas. Respond ONLY with the JSON object. Greatly increase task variety, focusing on the new vocabulary tasks.`;
        try {
            const response = await this.ai.models.generateContent({ model: "gemini-2.5-flash", contents: prompt, config: { responseMimeType: "application/json", temperature: 1.0 } });
            const task = this.parseJsonResponse(response.text);
            if (!task || !task.type || !task.title) throw new Error("Generated task is missing required fields.");
            if (!task.content && !task.questions) throw new Error("Task has no content or questions.");
            return task;
        } catch (error) {
            console.error("Error generating learning task:", error);
            throw new Error("Failed to generate a new learning task.");
        }
    }
    
    async evaluateTextTask(task, userInput) {
        let taskContextPrompt = "";
        switch (task.type) {
            case 'role-play':
                taskContextPrompt = `
- Scenario Context: "${task.context}"
- AI's First Line: "${task.content}"
- User's Goal: "${task.constraints}"
- Evaluation criteria: Did the user respond appropriately to the AI's line and work towards their goal? Is the grammar correct for their level?`;
                break;
            case 'error-correction':
                taskContextPrompt = `
- Incorrect sentence to be fixed: "${task.content}"
- Evaluation criteria: Did the user correctly identify and fix the error? Is the resulting sentence grammatically correct? The correct answer should be a single, complete sentence.`;
                break;
            case 'sentence-construction':
                taskContextPrompt = `
- Words to use: ${task.words?.join(' / ')}
- Instructions: "${task.content}"
- Constraints: "${task.constraints}"
- Evaluation criteria: Did the user use all the words correctly to form a sentence that meets the constraints?`;
                break;
            case 'word-formation':
                taskContextPrompt = `
- Sentence with word to change: "${task.content}"
- Base word: "${task.baseWord}"
- Instruction: "${task.constraints}"
- Evaluation criteria: Did the user provide the correct form of the word? The correct answer should be a single word. Check if the user's answer fits grammatically and contextually.`;
                break;
            default:
                return { isCorrect: false, feedback: "Неверный тип задания для оценки." };
        }

        const prompt = `
You are an expert AI English tutor. A learner at the ${task.level} level was given a task.
Evaluate their response based on the task's specific requirements.
The feedback MUST be in simple, encouraging, clear Russian. It should explain what was good and what could be improved.
Return your evaluation as a JSON object with this exact structure: { "isCorrect": boolean, "feedback": "string" }.
The \`isCorrect\` field should be \`true\` only if the user's response is grammatically correct and fully meets all task constraints.
- Task Type: ${task.type}
- User's Response: "${userInput}"
Here is the specific task information:
${taskContextPrompt}
Based on this, evaluate the user's response. Remember to be supportive.
Your entire response must be ONLY the JSON object.`;

        try {
            const response = await this.ai.models.generateContent({ model: "gemini-2.5-flash", contents: prompt, config: { responseMimeType: "application/json", temperature: 0.3 } });
            const evaluation = this.parseJsonResponse(response.text);
            if (!evaluation || typeof evaluation.isCorrect !== 'boolean' || !evaluation.feedback) throw new Error("Invalid evaluation format from AI.");
            return evaluation;
        } catch (error) {
            console.error("Error evaluating text task:", error);
            return { isCorrect: false, feedback: "Не удалось оценить ваш ответ. Пожалуйста, попробуйте еще раз." };
        }
    }

    async getExplanation(question, correctAnswer, userAnswer) {
        const prompt = `An English learner at a pre-intermediate level was asked a multiple-choice question: "${question}". The correct answer is "${correctAnswer}". The user incorrectly chose "${userAnswer}". Provide a very simple, one-sentence explanation in Russian about why the user's answer is wrong and the correct answer is right. Be concise and encouraging.`;
        try {
            const response = await this.ai.models.generateContent({ model: "gemini-2.5-flash", contents: prompt, config: {temperature: 0.1}});
            return response.text;
        } catch (error) {
            console.error("Error getting explanation:", error);
            return "Не удалось получить объяснение.";
        }
    }

    async getHelpFromGemini(query, level) {
        const prompt = `You are a friendly and supportive AI English tutor. A user at the ${level} level has a question or a request for their next lesson.
        User's request: "${query}"
        Provide a helpful and concise answer in simple Russian. You can explain a grammar rule, define a word, or confirm that their next task will be about their request. The answer should be encouraging.`;
        try {
            const response = await this.ai.models.generateContent({ model: "gemini-2.5-flash", contents: prompt, config: { temperature: 0.7 } });
            return response.text;
        } catch (error) {
            console.error("Error getting help from Gemini:", error);
            return "К сожалению, не удалось получить ответ от Gemini. Попробуйте еще раз.";
        }
    }
}

// --- From components/AuthScreen.tsx ---
const AuthScreen = ({ onGoogleSignIn, onApiKeySubmit, isSignedIn, userName, error, isLoading, isGsiLoaded }) => {
    const [apiKey, setApiKey] = useState('');
    const handleSubmitApiKey = (e) => {
        e.preventDefault();
        if (apiKey.trim()) {
            onApiKeySubmit(apiKey.trim());
        }
    };

    if (!isSignedIn) {
        return (
            <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950">
                <Card className="max-w-md w-full text-center animate-fade-in-up">
                    <h1 className="text-3xl font-bold text-slate-100 mb-2">Gemini English Tutor</h1>
                    <p className="text-slate-400 mb-8">Войдите с помощью Google, чтобы сохранять свой прогресс на Google Drive.</p>
                    {error && <p className="text-red-400 text-sm py-2">{error}</p>}
                    <Button 
                        onClick={onGoogleSignIn} 
                        variant="google" 
                        className="w-full text-lg py-3" 
                        isLoading={isLoading || !isGsiLoaded}
                        disabled={isLoading || !isGsiLoaded}
                        icon={<GoogleIcon />}
                    >
                        {isLoading ? "Вход..." : !isGsiLoaded ? "Загрузка сервисов..." : "Войти через Google"}
                    </Button>
                     <p className="text-xs text-slate-500 mt-4">Приложение создаст один файл в вашем Google Drive для хранения прогресса.</p>
                </Card>
            </div>
        );
    }
    
    // isSignedIn is true, now we need the Gemini Key
    return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950">
            <Card className="max-w-md w-full text-center animate-fade-in-up">
                <h1 className="text-2xl font-bold text-slate-100 mb-2">Добро пожаловать, {userName}!</h1>
                <p className="text-slate-400 mb-8">Для работы приложения введите ваш API ключ от Google Gemini. Он будет безопасно сохранен на вашем Google Drive.</p>
                <form onSubmit={handleSubmitApiKey} className='space-y-4'>
                    <input id="api-key-input" type="password" value={apiKey} onChange={(e) => setApiKey(e.target.value)} placeholder="Введите ваш Google AI API ключ" required className="w-full bg-slate-700 border border-slate-600 rounded-md px-4 py-2 text-white placeholder-slate-500 focus:ring-2 focus:ring-purple-500 focus:outline-none" />
                    {error && <p className="text-red-400 text-sm py-2">{error}</p>}
                    <Button type="submit" variant="primary" className="w-full text-lg py-3" disabled={!apiKey.trim() || isLoading} isLoading={isLoading}>
                        {isLoading ? 'Проверка ключа...' : 'Сохранить и начать'}
                    </Button>
                </form>
            </Card>
        </div>
    );
};

// --- From components/Header.tsx ---
const Header = ({ user, onSignOut, level, dailyStats }) => (
    <header className="py-4 px-4 sm:px-6 lg:px-8">
        <div className="max-w-4xl mx-auto flex justify-between items-center border-b border-slate-700/50 pb-4">
            <div className="flex items-center gap-3">
                <img src={user.imageUrl} alt={user.name} className="w-10 h-10 rounded-full border-2 border-slate-600" />
                <div className="flex items-center gap-x-3 flex-wrap">
                    <h1 className="font-bold text-slate-100">{user.name}</h1>
                    {level && <span className="bg-purple-600/50 text-purple-300 text-xs font-medium px-2.5 py-0.5 rounded-full border border-purple-500">{level}</span>}
                    <div className="text-sm text-slate-400">
                        <span>Задания сегодня: </span>
                        <span className="font-bold text-green-400">{dailyStats.correct}</span>
                        <span> / </span>
                        <span className="font-bold text-slate-300">{dailyStats.completed}</span>
                    </div>
                </div>
            </div>
            <Button onClick={onSignOut} variant="secondary">Выйти</Button>
        </div>
    </header>
);

// --- From components/WelcomeScreen.tsx ---
const WelcomeScreen = ({ user, onStart }) => (
    <div className="flex flex-col items-center justify-center py-12">
        <Card className="max-w-2xl text-center animate-fade-in-up">
            <img src={user.imageUrl} alt={user.name} className="w-24 h-24 rounded-full mx-auto mb-4 border-4 border-slate-700" />
            <h1 className="text-4xl sm:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-500 to-purple-600 mb-4">Добро пожаловать, {user.name}!</h1>
            <p className="text-slate-300 text-lg mb-8">Пройдите быстрый тест, чтобы определить свой уровень, и получите персонализированные задания для изучения английского языка.</p>
            <Button onClick={onStart} className="px-8 py-3 text-lg">Начать тест</Button>
        </Card>
    </div>
);

// --- From components/Assessment.tsx ---
const Assessment = ({ questions, onComplete }) => {
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [selectedAnswer, setSelectedAnswer] = useState(null);
    const [isAnswered, setIsAnswered] = useState(false);
    const [scores, setScores] = useState({ [CEFRLevel.A1]: 0, [CEFRLevel.A2]: 0, [CEFRLevel.B1]: 0, [CEFRLevel.B2]: 0, [CEFRLevel.C1]: 0 });
    const currentQuestion = questions[currentQuestionIndex];
    const handleAnswerSelect = (option) => {
        if (isAnswered) return;
        setSelectedAnswer(option);
        setIsAnswered(true);
        if (option === currentQuestion.correctAnswer) setScores(prev => ({ ...prev, [currentQuestion.level]: (prev[currentQuestion.level] || 0) + 1 }));
    };
    const handleNext = () => {
        if (currentQuestionIndex < questions.length - 1) {
            setCurrentQuestionIndex(prev => prev + 1);
            setSelectedAnswer(null);
            setIsAnswered(false);
        } else {
            const questionsPerLevel = {};
            questions.forEach(q => { questionsPerLevel[q.level] = (questionsPerLevel[q.level] || 0) + 1; });
            let determinedLevel = CEFRLevel.A1;
            for (const level of CEFR_LEVELS_ORDER) {
                if ((questionsPerLevel[level] || 0) > 0 && (scores[level] || 0) / questionsPerLevel[level] >= 0.5) determinedLevel = level;
                else if ((questionsPerLevel[level] || 0) > 0) break;
            }
            onComplete(determinedLevel);
        }
    };
    const getButtonClass = (option) => {
        if (!isAnswered) return 'bg-slate-700 hover:bg-slate-600';
        if (option === currentQuestion.correctAnswer) return 'bg-green-600';
        if (option === selectedAnswer) return 'bg-red-600';
        return 'bg-slate-700 opacity-60';
    };
    return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950">
            <Card className="w-full max-w-2xl">
                <div className="mb-4">
                    <div className="flex justify-between mb-1"><span className="text-base font-medium text-purple-400">Прогресс</span><span className="text-sm font-medium text-purple-400">{currentQuestionIndex + 1} / {questions.length}</span></div>
                    <div className="w-full bg-slate-700 rounded-full h-2.5"><div className="bg-purple-600 h-2.5 rounded-full" style={{ width: `${((currentQuestionIndex + 1) / questions.length) * 100}%` }}></div></div>
                </div>
                <h2 className="text-2xl font-bold text-slate-100 mb-2">{`Вопрос ${currentQuestionIndex + 1}`}</h2>
                <div className="flex items-start gap-2 text-slate-300 text-lg mb-6">
                    <p className="flex-grow">{currentQuestion.question}</p>
                    <SpeakButton text={currentQuestion.question} />
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">{currentQuestion.options.map((option, index) => <button key={index} onClick={() => handleAnswerSelect(option)} disabled={isAnswered} className={`w-full p-4 rounded-lg text-left transition-colors duration-300 flex justify-between items-center ${getButtonClass(option)}`}>
                    <span>{option}</span>
                    <SpeakButton text={option} />
                </button>)}</div>
                {isAnswered && <div className="text-right"><Button onClick={handleNext}>{currentQuestionIndex < questions.length - 1 ? 'Следующий вопрос' : 'Завершить'}</Button></div>}
            </Card>
        </div>
    );
};

// --- From components/ResultsScreen.tsx ---
const ResultsScreen = ({ level, onStartLearning }) => (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950">
        <Card className="max-w-xl text-center animate-fade-in-up">
            <h2 className="text-3xl font-bold text-slate-100 mb-2">Тест завершен!</h2>
            <p className="text-slate-300 text-lg mb-4">Ваш предполагаемый уровень владения английским:</p>
            <div className="bg-purple-600 text-white text-4xl font-bold rounded-lg py-4 px-8 inline-block mb-8">{level}</div>
            <p className="text-slate-400 mb-8">Теперь вы готовы начать выполнять задания, соответствующие вашему уровню.</p>
            <Button onClick={onStartLearning} className="px-8 py-3 text-lg">Начать обучение</Button>
        </Card>
    </div>
);

// --- From components/ProgressTracker.tsx ---
const ProgressTracker = ({ history, isPreLevelUp }) => {
    const correctCount = history.filter(h => h).length;
    const progressPercentage = Math.min((correctCount / PROGRESS_UNLOCK_THRESHOLD) * 100, 100);
    return (
        <div className="bg-slate-800/40 border border-slate-700/50 rounded-xl shadow-lg p-4">
            <div className="flex justify-between items-center mb-2"><h3 className="font-bold text-slate-200">Прогресс к следующему уровню</h3><span className="text-lg font-mono font-bold text-purple-300">{correctCount} / {PROGRESS_UNLOCK_THRESHOLD}</span></div>
            <p className="text-sm text-slate-400 mb-3">Правильно ответьте на {PROGRESS_UNLOCK_THRESHOLD} из последних {PROGRESS_HISTORY_LENGTH} заданий, чтобы разблокировать тест на повышение уровня.</p>
            <div className="w-full bg-slate-700 rounded-full h-4 relative overflow-hidden"><div className="bg-gradient-to-r from-fuchsia-600 to-purple-600 h-4 rounded-full transition-all duration-500 ease-out" style={{ width: `${progressPercentage}%` }}></div></div>
            {isPreLevelUp && (
                <div className="mt-3 text-center text-sm text-yellow-300 bg-yellow-900/40 border border-yellow-800/60 rounded-lg py-2 px-3">
                    <p>🚀 <strong>Готовимся к экзамену!</strong> Задания становятся сложнее, чтобы лучше подготовить вас к тесту.</p>
                </div>
            )}
        </div>
    );
};

// --- From components/LevelUpAssessment.tsx ---
const LevelUpAssessment = ({ questions, onComplete }) => {
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [selectedAnswer, setSelectedAnswer] = useState(null);
    const [correctAnswersCount, setCorrectAnswersCount] = useState(0);
    const [isFinished, setIsFinished] = useState(false);

    useEffect(() => {
        if (questions.length > 0 && currentQuestionIndex >= questions.length && !isFinished) {
            setIsFinished(true);
            onComplete(correctAnswersCount / questions.length);
        }
    }, [currentQuestionIndex, correctAnswersCount, questions.length, onComplete, isFinished]);

    const handleAnswerSelect = (option) => {
        if (selectedAnswer) return;
        setSelectedAnswer(option);
        if (option === questions[currentQuestionIndex].correctAnswer) {
            setCorrectAnswersCount(prev => prev + 1);
        }
        setTimeout(() => {
            if (currentQuestionIndex < questions.length) {
                setCurrentQuestionIndex(prev => prev + 1);
                setSelectedAnswer(null);
            }
        }, 800);
    };

    const getButtonClassForLevelUp = (option) => {
        if (!selectedAnswer) return 'bg-slate-700 hover:bg-slate-600';
        const isCorrect = option === questions[currentQuestionIndex].correctAnswer;
        const isSelected = option === selectedAnswer;
        if (isCorrect) return 'bg-green-600'; 
        if (isSelected && !isCorrect) return 'bg-red-600';
        return 'bg-slate-700 opacity-50';
    };

    if (currentQuestionIndex >= questions.length) {
        return <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950"><Loader text="Подсчет результатов..." /></div>;
    }
    const currentQuestion = questions[currentQuestionIndex];
    if (!currentQuestion) {
       return <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950"><Loader text="Загрузка вопроса..." /></div>;
    }

    return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950">
            <Card className="w-full max-w-2xl">
                <div className="mb-6"><h2 className="text-3xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-500 to-purple-600 mb-2">Тест на повышение уровня</h2><p className="text-center text-slate-400">Для прохождения нужно ответить правильно на {LEVEL_UP_PASS_PERCENTAGE * 100}% вопросов.</p></div>
                <div className="mb-4">
                    <div className="flex justify-between mb-1"><span className="text-base font-medium text-purple-400">Прогресс</span><span className="text-sm font-medium text-purple-400">{currentQuestionIndex + 1} / {questions.length}</span></div>
                    <div className="w-full bg-slate-700 rounded-full h-2.5"><div className="bg-purple-600 h-2.5 rounded-full transition-width duration-300" style={{ width: `${((currentQuestionIndex + 1) / questions.length) * 100}%` }}></div></div>
                </div>
                <h3 className="text-2xl font-bold text-slate-100 mb-2">{`Вопрос ${currentQuestionIndex + 1}`}</h3>
                <div className="flex items-start gap-2 text-slate-300 text-lg mb-6">
                    <p className="flex-grow">{currentQuestion.question}</p>
                    <SpeakButton text={currentQuestion.question}/>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {currentQuestion.options.map((option, index) => (
                        <button key={index} onClick={() => handleAnswerSelect(option)} disabled={!!selectedAnswer} className={`w-full p-4 rounded-lg text-left transition-colors duration-300 flex justify-between items-center ${getButtonClassForLevelUp(option)}`}>
                            <span>{option}</span>
                            <SpeakButton text={option} />
                        </button>
                    ))}
                </div>
            </Card>
        </div>
    );
};


// --- From components/LevelUpResultsScreen.tsx ---
const LevelUpResultsScreen = ({ isSuccess, newLevel, onContinue }) => (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-950">
        <Card className="max-w-xl text-center animate-fade-in-up">
            {isSuccess ? (
                <><h2 className="text-3xl font-bold text-green-400 mb-2">Поздравляем!</h2><p className="text-slate-300 text-lg mb-4">Вы успешно прошли тест и перешли на новый уровень:</p><div className="bg-green-600 text-white text-4xl font-bold rounded-lg py-4 px-8 inline-block mb-8">{newLevel}</div><p className="text-slate-400 mb-8">Ваш прогресс сброшен. Продолжайте в том же духе!</p></>
            ) : (
                <><h2 className="text-3xl font-bold text-yellow-400 mb-2">Почти получилось!</h2><p className="text-slate-300 text-lg mb-4">К сожалению, в этот раз не удалось пройти тест.</p><p className="text-slate-400 mb-8">Не волнуйтесь! Ваш прогресс сброшен, и вы можете продолжить практиковаться на своем текущем уровне, чтобы попробовать снова.</p></>
            )}
            <Button onClick={onContinue} className="px-8 py-3 text-lg">Продолжить обучение</Button>
        </Card>
    </div>
);

// --- From components/LearningDashboard.tsx ---
const LearningDashboard = ({ geminiService, userData, onTaskComplete, onStartLevelUpTest, onFeedbackSubmit, onGlobalInstructionsChange }) => {
    const [task, setTask] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const [selectedAnswers, setSelectedAnswers] = useState({});
    const [taskResults, setTaskResults] = useState([]);
    const [explanations, setExplanations] = useState({});
    const [userInput, setUserInput] = useState("");
    const [evaluation, setEvaluation] = useState(null);
    const [showResults, setShowResults] = useState(false);
    const [isChecking, setIsChecking] = useState(false);
    const [showFeedbackForm, setShowFeedbackForm] = useState(false);
    const [feedbackText, setFeedbackText] = useState("");
    const [feedbackSubmitted, setFeedbackSubmitted] = useState(false);
    
    const [isHelpModalOpen, setIsHelpModalOpen] = useState(false);
    const [helpQuery, setHelpQuery] = useState("");
    const [isHelpLoading, setIsHelpLoading] = useState(false);
    const [helpResponse, setHelpResponse] = useState(null);
    
    const [isPreferencesModalOpen, setIsPreferencesModalOpen] = useState(false);
    const [newInstruction, setNewInstruction] = useState("");
    
    const [isLearnedWordsModalOpen, setIsLearnedWordsModalOpen] = useState(false);


    const INTERACTIVE_TASK_TYPES = ['sentence-construction', 'error-correction', 'role-play', 'word-formation'];

    const correctCount = userData.taskHistory.filter(Boolean).length;
    const canAttemptLevelUp = correctCount >= PROGRESS_UNLOCK_THRESHOLD;
    const preLevelUpThreshold = 50;
    const isPreLevelUp = !canAttemptLevelUp && correctCount >= preLevelUpThreshold;

    const fetchTask = useCallback(async (isRetry = false) => {
        if (!isRetry) {
            setTask(null); setSelectedAnswers({}); setShowResults(false); setTaskResults([]); setExplanations({}); setIsChecking(false); setUserInput(""); setEvaluation(null); setShowFeedbackForm(false); setFeedbackText(""); setFeedbackSubmitted(false);
            setIsLoading(true); setError(null);
        } else { setError(null); setIsLoading(true); }
        try {
            const newTask = await geminiService.generateLearningTask(userData.level, userData.feedbackHistory, isPreLevelUp, userData.globalInstructions, userData.vocabularyProgress, userData.recentMistakes, userData.shortTermTaskTypeHistory || [], userData.fullTaskTypeHistory || [], userData.recentWordsPracticed || []);
            if (!newTask) throw new Error("Received empty task from API.");
            setTask(newTask);
        } catch (err) { setError(err.message || 'An unknown error occurred.'); } 
        finally { setIsLoading(false); }
    }, [userData.level, userData.feedbackHistory, userData.globalInstructions, userData.vocabularyProgress, userData.recentMistakes, geminiService, isPreLevelUp, userData.shortTermTaskTypeHistory, userData.fullTaskTypeHistory, userData.recentWordsPracticed]);
    
    useEffect(() => {
        fetchTask();
    }, []);

    const handleCheckAnswers = async () => {
        if (!task) return;
        setIsChecking(true);
        if (task.type && INTERACTIVE_TASK_TYPES.includes(task.type)) {
            const result = await geminiService.evaluateTextTask(task, userInput);
            setEvaluation(result);
            onTaskComplete({results: [{ isCorrect: result.isCorrect, wordToLearn: task.wordToLearn }], task});
        } else if (task.questions) {
            const newExplanations = {};
            const explanationPromises = task.questions.map((q, index) => {
                const userAnswer = selectedAnswers[index];
                if (userAnswer && userAnswer !== q.correctAnswer) return geminiService.getExplanation(q.question, q.correctAnswer, userAnswer).then(exp => { newExplanations[index] = exp; });
                return Promise.resolve();
            });
            await Promise.all(explanationPromises);
            setExplanations(newExplanations);
            const resultsPayload = task.questions.map((q, i) => ({
                isCorrect: selectedAnswers[i] === q.correctAnswer,
                wordToLearn: q.wordToLearn
            }));
            setTaskResults(resultsPayload.map(r => r.isCorrect));
            onTaskComplete({results: resultsPayload, task});
        }
        setShowResults(true); setIsChecking(false);
    };

    const handleFeedbackFormSubmit = (e) => {
        e.preventDefault();
        if (feedbackText.trim()) {
            onFeedbackSubmit(feedbackText.trim());
            setFeedbackSubmitted(true);
            setShowFeedbackForm(false);
        }
    };
    
    const handleHelpModalClose = () => {
        setIsHelpModalOpen(false);
        setHelpQuery("");
        setHelpResponse(null);
        setIsHelpLoading(false);
    };

    const handleHelpSubmit = async (e) => {
        e.preventDefault();
        if (!helpQuery.trim() || !userData.level) return;
        setIsHelpLoading(true);
        setHelpResponse(null);
        const response = await geminiService.getHelpFromGemini(helpQuery, userData.level);
        setHelpResponse(response);
        onFeedbackSubmit(`User explicitly asked for a task about: "${helpQuery.trim()}"`);
        setIsHelpLoading(false);
        setHelpQuery("");
    };

    const handleAddInstruction = () => {
        if (newInstruction.trim()) {
            onGlobalInstructionsChange([...userData.globalInstructions, newInstruction.trim()]);
            setNewInstruction("");
        }
    };

    const handleDeleteInstruction = (indexToDelete) => {
        onGlobalInstructionsChange(userData.globalInstructions.filter((_, index) => index !== indexToDelete));
    };

    const isInteractiveTask = task?.type && INTERACTIVE_TASK_TYPES.includes(task.type);

    const { learningWords, learnedWords } = Object.entries(userData.vocabularyProgress)
        .reduce((acc, [word, count]) => {
            if (count >= VOCABULARY_MASTERY_THRESHOLD) {
                acc.learnedWords.push(word);
            } else if (count >= 0) {
                acc.learningWords.push({ word, count });
            }
            return acc;
        }, { learningWords: [], learnedWords: [] });
    
    learningWords.sort((a, b) => a.count - b.count); // Show words with less progress first
    learnedWords.sort();


    const renderQuizTask = () => {
        if (!task || !task.questions) return null;

        return (
            <>
                <div className="flex items-start gap-2 text-slate-300 text-lg mb-6 whitespace-pre-wrap">
                    <p className="flex-grow">{task.content}</p>
                    <SpeakButton text={task.content.replace(/___/g, 'blank')} />
                </div>
                <div className="space-y-6">
                    {task.questions.map((q, qIndex) => (
                        <div key={qIndex}>
                             <div className="flex items-start gap-2 font-semibold text-slate-200 mb-3">
                                <h3 className="flex-grow">{q.question}</h3>
                                <SpeakButton text={q.question} />
                            </div>
                            <div className="grid grid-cols-1 gap-3">
                                {q.options.map((option, oIndex) => {
                                    const isSelected = selectedAnswers[qIndex] === option;
                                    const isCorrect = task.questions?.[qIndex]?.correctAnswer === option;
                                    
                                    let buttonClass = 'bg-slate-700 hover:bg-slate-600';
                                    let icon = null;

                                    if (showResults) {
                                        if (isCorrect) {
                                            buttonClass = 'bg-green-800/50 border border-green-600 text-slate-100 cursor-default';
                                            icon = <CheckCircleIcon/>;
                                        } else if (isSelected) {
                                            buttonClass = 'bg-red-800/50 border border-red-600 text-slate-100 cursor-default';
                                            icon = <XCircleIcon/>;
                                        } else {
                                            buttonClass = 'bg-slate-800/60 opacity-60 cursor-not-allowed';
                                        }
                                    } else if (isSelected) {
                                        buttonClass = 'bg-purple-600 ring-2 ring-offset-2 ring-offset-slate-800 ring-purple-500';
                                    }

                                    return (
                                        <button 
                                            key={oIndex} 
                                            onClick={() => !showResults && setSelectedAnswers(prev => ({ ...prev, [qIndex]: option }))} 
                                            disabled={showResults} 
                                            className={`p-3 rounded-lg text-left transition-all duration-300 flex justify-between items-center ${buttonClass}`}
                                        >
                                            <span className="flex-1 pr-4">{option}</span>
                                            <div className="flex items-center gap-3 shrink-0">
                                                <SpeakButton text={option}/>
                                                {icon}
                                            </div>
                                        </button>
                                    );
                                })}
                            </div>
                            {showResults && explanations[qIndex] && (
                                <div className="mt-3 p-3 bg-red-900/50 border border-red-700/50 rounded-lg">
                                    <h4 className="font-semibold text-red-200 mb-1">Разбор ошибки:</h4>
                                    <p className="text-red-300">{explanations[qIndex]}</p>
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            </>
        );
    };

    const renderInteractiveTask = () => {
        if (!task) return null;

        const getContextDescription = () => {
            switch (task.type) {
                case 'role-play':
                    return (
                        <div className="text-slate-400 mb-4 space-y-2">
                             <div className="flex justify-between items-start gap-2"><p><strong>Сценарий:</strong> {task.context}</p><SpeakButton text={task.context || ''}/></div>
                             <div className="flex justify-between items-start gap-2"><p><strong>Ваша задача:</strong> {task.constraints}</p><SpeakButton text={task.constraints || ''}/></div>
                        </div>
                    );
                case 'error-correction':
                     return (
                        <div className="text-slate-400 mb-2 space-y-1">
                            <p><strong>Задание:</strong> Найдите и исправьте ошибку в предложении ниже.</p>
                            {task.context && <div className="flex justify-between items-start gap-2"><p><strong>Контекст:</strong> {task.context}</p><SpeakButton text={task.context}/></div>}
                        </div>
                    );
                case 'sentence-construction':
                    return (
                        <div className="text-slate-400 mb-4 space-y-2">
                             <div className="flex justify-between items-start gap-2"><p><strong>Задание:</strong> {task.content}</p><SpeakButton text={task.content}/></div>
                            <p className="font-medium text-slate-300">Используйте эти слова:</p>
                            <div className="flex flex-wrap gap-2">{task.words?.map((word, i) => <div key={i} className="flex items-center gap-2 font-mono text-purple-300 bg-slate-700/50 px-2 py-1 rounded-md border border-slate-600"><span>{word}</span><SpeakButton text={word}/></div>)}</div>
                            {task.constraints && <div className="flex justify-between items-start gap-2"><p><strong>Условие:</strong> {task.constraints}</p><SpeakButton text={task.constraints}/></div>}
                        </div>
                    );
                case 'word-formation':
                    return (
                        <div className="text-slate-400 mb-4 space-y-2">
                             <div className="flex justify-between items-start gap-2"><p><strong>Задание:</strong> {task.constraints}</p><SpeakButton text={task.constraints || ''}/></div>
                             <div className="flex justify-between items-start gap-2"><p><strong>Предложение:</strong> <span className="italic">{task.content}</span></p><SpeakButton text={task.content || ''}/></div>
                        </div>
                    );
                default: return null;
            }
        }

        return (
            <div>
                <div className="mb-4">{getContextDescription()}</div>
                {task.type === 'role-play' && (<div className="mb-4 p-3 border-l-4 border-purple-500 bg-slate-900/50">
                    <p className="font-semibold">Собеседник:</p>
                    <div className="flex items-center gap-2">
                       <p className="flex-grow italic text-slate-300">"{task.content}"</p>
                       <SpeakButton text={task.content}/>
                    </div>
                </div>)}
                <textarea 
                  value={userInput}
                  onChange={e => setUserInput(e.target.value)}
                  disabled={showResults}
                  placeholder={task.type === 'role-play' ? 'Ваш ответ...' : 'Напишите правильный ответ...'}
                  className="w-full bg-slate-700 border border-slate-600 rounded-md px-4 py-2 text-white placeholder-slate-500 focus:ring-2 focus:ring-purple-500 focus:outline-none disabled:opacity-70"
                />
                {showResults && evaluation && (
                    <div className={`mt-4 p-4 rounded-lg border ${evaluation.isCorrect ? 'bg-green-900/50 border-green-700' : 'bg-red-900/50 border-red-700'}`}>
                        <h4 className={`font-bold text-lg mb-2 ${evaluation.isCorrect ? 'text-green-300' : 'text-red-300'}`}>
                           {evaluation.isCorrect ? 'Отлично!' : 'Есть над чем поработать'} 
                        </h4>
                        <p className={`${evaluation.isCorrect ? 'text-green-200' : 'text-red-200'}`}>{evaluation.feedback}</p>
                    </div>
                )}
            </div>
        );
    };

    const isQuizTask = task?.questions && task.questions.length > 0;
    const allQuestionsAnswered = isQuizTask && Object.keys(selectedAnswers).length === task.questions.length;
    const canCheck = (isQuizTask && allQuestionsAnswered) || (isInteractiveTask && userInput.trim() !== "");
    
    if (isLoading) {
        return (
            <div className="flex items-center justify-center p-8">
                <Loader text="Создаю для вас новое задание..." />
            </div>
        );
    }
    
    if (error) {
        return (
            <div className="flex flex-col items-center justify-center p-8 text-center">
                <p className="text-red-400 text-lg mb-4">{error}</p>
                <Button onClick={() => fetchTask(true)}>Попробовать снова</Button>
            </div>
        );
    }

    if (!task) {
        return <div className="p-8 text-center text-slate-400">Не удалось загрузить задание.</div>;
    }
    
    return (
        <main className="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8 space-y-8">
            <ProgressTracker history={userData.taskHistory} isPreLevelUp={isPreLevelUp} />
            
            {canAttemptLevelUp && (
                <Card className="bg-gradient-to-r from-fuchsia-600 to-purple-600 text-white text-center">
                    <h2 className="text-2xl font-bold mb-2">Вы готовы к новому уровню!</h2>
                    <p className="mb-4">Вы отлично поработали. Пройдите тест, чтобы перейти на следующий уровень.</p>
                    <Button onClick={onStartLevelUpTest} variant="secondary" className="bg-white text-purple-700 hover:bg-slate-200">Начать тест на повышение уровня</Button>
                </Card>
            )}

            <Card>
                <h2 className="text-2xl font-bold text-slate-100 mb-1">{task.title}</h2>
                <p className="text-sm text-slate-500 mb-6">Уровень: {task.level}</p>

                {isQuizTask ? renderQuizTask() : renderInteractiveTask()}
                
                <div className="mt-8 flex flex-col sm:flex-row gap-4 justify-between items-center">
                    <div className="flex gap-2">
                       <Button onClick={() => setIsHelpModalOpen(true)} variant='ghost' className="text-sm">Помощь</Button>
                       <Button onClick={() => setIsPreferencesModalOpen(true)} variant='ghost' className="text-sm">Настройки</Button>
                       <Button onClick={() => setIsLearnedWordsModalOpen(true)} variant='secondary' className="text-sm" icon={<BookOpenIcon />}>Словарь</Button>
                    </div>
                   
                    {showResults ? (
                         <Button onClick={() => fetchTask()} className="w-full sm:w-auto">Следующее задание</Button>
                    ) : (
                         <Button onClick={handleCheckAnswers} disabled={!canCheck || isChecking} isLoading={isChecking} className="w-full sm:w-auto">
                            {isChecking ? "Проверяю..." : "Проверить"}
                         </Button>
                    )}
                </div>
            </Card>

            {!showResults && !showFeedbackForm && !feedbackSubmitted && (
                 <div className="text-center">
                     <Button variant="ghost" onClick={() => setShowFeedbackForm(true)}>Задание не нравится?</Button>
                 </div>
            )}
            
            {showFeedbackForm && (
                <Card className="mt-4">
                    <form onSubmit={handleFeedbackFormSubmit}>
                        <h3 className="text-lg font-semibold mb-2">Что не так с заданием?</h3>
                        <p className="text-sm text-slate-400 mb-3">Ваш отзыв поможет AI сделать следующее задание лучше (например: "сделай задание про путешествия" или "это слишком сложно").</p>
                        <textarea value={feedbackText} onChange={(e) => setFeedbackText(e.target.value)} rows={2} className="w-full bg-slate-700 border border-slate-600 rounded-md px-4 py-2 text-white placeholder-slate-500 focus:ring-2 focus:ring-purple-500 focus:outline-none mb-3" placeholder="Ваш отзыв..."/>
                        <div className="flex justify-end gap-3">
                            <Button type="button" variant="secondary" onClick={() => setShowFeedbackForm(false)}>Отмена</Button>
                            <Button type="submit" disabled={!feedbackText.trim()}>Отправить</Button>
                        </div>
                    </form>
                </Card>
            )}
            {feedbackSubmitted && <p className="text-center text-green-400">Спасибо! Я учту ваш отзыв в следующем задании.</p>}
            
            {/* Help Modal */}
            {isHelpModalOpen && (
                <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={handleHelpModalClose}>
                    <Card className="w-full max-w-lg" onClick={(e) => e.stopPropagation()}>
                        <h3 className="text-xl font-bold mb-4">Чем могу помочь?</h3>
                        <p className="text-slate-400 mb-4">Задайте вопрос по грамматике, попросите объяснить слово или просто скажите, какое задание вы хотите получить следующим.</p>
                        <form onSubmit={handleHelpSubmit}>
                            <textarea value={helpQuery} onChange={(e) => setHelpQuery(e.target.value)} rows={3} className="w-full bg-slate-700 border border-slate-600 rounded-md px-4 py-2 text-white placeholder-slate-500 focus:ring-2 focus:ring-purple-500 focus:outline-none mb-4" placeholder="Например: 'В чем разница между Present Perfect и Past Simple?'"/>
                            <div className="flex justify-end gap-3">
                                <Button type="button" variant="secondary" onClick={handleHelpModalClose}>Закрыть</Button>
                                <Button type="submit" disabled={!helpQuery.trim() || isHelpLoading} isLoading={isHelpLoading}>Спросить</Button>
                            </div>
                        </form>
                        {isHelpLoading && <Loader text="Gemini думает..." />}
                        {helpResponse && <div className="mt-4 p-4 bg-slate-700/50 rounded-lg whitespace-pre-wrap">{helpResponse}</div>}
                    </Card>
                </div>
            )}
            
            {/* Preferences Modal */}
            {isPreferencesModalOpen && (
                <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={() => setIsPreferencesModalOpen(false)}>
                    <Card className="w-full max-w-lg" onClick={(e) => e.stopPropagation()}>
                        <h3 className="text-xl font-bold mb-2">Постоянные инструкции</h3>
                        <p className="text-slate-400 mb-4">Эти инструкции будут применяться ко всем будущим заданиям. Например: "Я работаю в IT, давай задания на эту тему" или "Я не люблю ролевые игры".</p>
                         <div className="space-y-3 mb-4">
                            {userData.globalInstructions.map((instr, index) => (
                                <div key={index} className="flex items-center justify-between bg-slate-700/80 p-3 rounded-lg">
                                    <span className="text-slate-300">{instr}</span>
                                    <button onClick={() => handleDeleteInstruction(index)} className="text-red-400 hover:text-red-300">&times;</button>
                                </div>
                            ))}
                        </div>
                        <div className="flex gap-2">
                             <input type="text" value={newInstruction} onChange={(e) => setNewInstruction(e.target.value)} placeholder="Новая инструкция..." className="flex-grow w-full bg-slate-700 border border-slate-600 rounded-md px-4 py-2 text-white placeholder-slate-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"/>
                             <Button onClick={handleAddInstruction} disabled={!newInstruction.trim()}>Добавить</Button>
                        </div>
                         <div className="text-right mt-6">
                            <Button onClick={() => setIsPreferencesModalOpen(false)}>Готово</Button>
                         </div>
                    </Card>
                </div>
            )}
            
            {/* Vocabulary Modal */}
            {isLearnedWordsModalOpen && (
                 <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={() => setIsLearnedWordsModalOpen(false)}>
                    <Card className="w-full max-w-lg max-h-[80vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
                        <h3 className="text-xl font-bold mb-4">Ваш словарь</h3>
                        <div className="flex-grow overflow-y-auto pr-2 space-y-4">
                            <div>
                                <h4 className="font-semibold text-purple-300 mb-2">Изучаемые слова ({learningWords.length}/{CONCURRENT_WORDS_TO_LEARN})</h4>
                                {learningWords.length > 0 ? (
                                    <div className="space-y-2">
                                        {learningWords.map(({word, count}) => (
                                           <div key={word} className="flex items-center gap-2 text-sm">
                                                <div className="w-full bg-slate-700 rounded-full h-2.5"><div className="bg-purple-600 h-2.5 rounded-full" style={{ width: `${(count / VOCABULARY_MASTERY_THRESHOLD) * 100}%` }}></div></div>
                                                <span className="text-slate-300 w-40 truncate" title={word}>{word}</span>
                                                <span className="text-slate-500 font-mono text-xs w-12 text-right">{count}/{VOCABULARY_MASTERY_THRESHOLD}</span>
                                           </div>
                                        ))}
                                    </div>
                                ) : <p className="text-slate-400 italic">Изучаемые слова появятся здесь после выполнения заданий на лексику.</p>}
                            </div>
                            <div>
                                <h4 className="font-semibold text-green-300 mb-2">Выученные слова ({learnedWords.length})</h4>
                                {learnedWords.length > 0 ? (
                                    <div className="flex flex-wrap gap-x-4 gap-y-1">
                                        {learnedWords.map(word => <span key={word} className="text-slate-400">{word}</span>)}
                                    </div>
                                ) : <p className="text-slate-400 italic">Здесь будет ваш список освоенных слов.</p>}
                            </div>
                        </div>
                         <div className="text-right mt-6 pt-4 border-t border-slate-700">
                            <Button onClick={() => setIsLearnedWordsModalOpen(false)}>Закрыть</Button>
                         </div>
                    </Card>
                 </div>
            )}
        </main>
    );
};


// --- From App.tsx (Reconstructed and Refactored) ---
const App = () => {
    const [appState, setAppState] = useState(AppState.AUTH);
    const [userData, setUserData] = useState(null);
    const [geminiService, setGeminiService] = useState(null);
    const [error, setError] = useState(null);
    const [assessmentQuestions, setAssessmentQuestions] = useState([]);
    const [levelUpQuestions, setLevelUpQuestions] = useState([]);
    
    // New state for Google Identity Services
    const [gsiLoaded, setGsiLoaded] = useState(false);
    const [isSignedIn, setIsSignedIn] = useState(false);
    const tokenClient = useRef(null);
    const accessToken = useRef(null);
    const driveFileId = useRef(null);
    const tempUser = useRef(null);

    // Initialize GSI Client
    useEffect(() => {
        const checkGsi = () => {
            if (window.google) {
                setGsiLoaded(true);
                tokenClient.current = window.google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: DRIVE_SCOPES,
                    callback: handleTokenResponse,
                });
            } else {
                setTimeout(checkGsi, 100); // Poll until GSI is loaded
            }
        };
        checkGsi();
    }, []);

    const findOrCreateDriveFile = useCallback(async (token) => {
        setError(null);
        setAppState(AppState.AUTH_LOADING);
        try {
            // 1. Search for the file
            const searchResponse = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${DRIVE_APP_FILE_NAME}'&spaces=drive&fields=files(id,name)`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!searchResponse.ok) throw new Error("Не удалось получить доступ к Google Drive. Попробуйте еще раз.");
            const searchData = await searchResponse.json();

            if (searchData.files && searchData.files.length > 0) {
                // File exists, read it
                driveFileId.current = searchData.files[0].id;
                const fileContentResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${driveFileId.current}?alt=media`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const savedData = await fileContentResponse.json();
                
                const service = new GeminiService(savedData.apiKey);
                const connectionTest = await service.testConnection();
                 if (!connectionTest.success) {
                    throw new Error(connectionTest.error);
                 }
                setGeminiService(service);
                setUserData(savedData);
                setAppState(AppState.LEARNING);

            } else {
                // File doesn't exist, user needs to provide API key
                 if (tempUser.current) {
                    setUserData({
                         user: tempUser.current,
                         apiKey: '', level: null, taskHistory: [],
                         dailyStats: { date: new Date().toISOString().split('T')[0], completed: 0, correct: 0 },
                         feedbackHistory: [], globalInstructions: [], vocabularyProgress: {}, recentMistakes: [], 
                         shortTermTaskTypeHistory: [], fullTaskTypeHistory: [], recentWordsPracticed: []
                     });
                 }
                 setAppState(AppState.AUTH); // Go back to auth screen to ask for key
            }
        } catch (err) {
            setError(err.message || 'Произошла ошибка при работе с Google Drive.');
            setAppState(AppState.AUTH);
            setIsSignedIn(false);
        }
    }, []);
    
    const handleTokenResponse = useCallback((response) => {
        if (response.error) {
            setError("Ошибка авторизации: " + response.error);
            setAppState(AppState.AUTH);
            return;
        }
        accessToken.current = response.access_token;
        setIsSignedIn(true);
        // Get user profile info
        fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
             headers: { 'Authorization': `Bearer ${accessToken.current}` }
        })
        .then(res => res.json())
        .then(profile => {
             tempUser.current = { name: profile.given_name || profile.name, imageUrl: profile.picture };
             findOrCreateDriveFile(accessToken.current);
        })
        .catch(err => {
            setError("Не удалось получить информацию о пользователе.");
            setAppState(AppState.AUTH);
        });

    }, [findOrCreateDriveFile]);

    const handleGoogleSignIn = () => {
        if (tokenClient.current) {
            setAppState(AppState.AUTH_LOADING);
            tokenClient.current.requestAccessToken();
        } else {
            setError("Сервис аутентификации еще не загружен.");
        }
    };
    
    const saveToDrive = useCallback(debounce(async (dataToSave) => {
        if (!driveFileId.current || !accessToken.current) return;
        try {
            const boundary = '-------314159265358979323846';
            const delimiter = "\r\n--" + boundary + "\r\n";
            const close_delim = "\r\n--" + boundary + "--";

            const metadata = { mimeType: 'application/json' };
            const multipartRequestBody =
                delimiter +
                'Content-Type: application/json\r\n\r\n' +
                JSON.stringify(metadata) +
                delimiter +
                'Content-Type: application/json\r\n\r\n' +
                JSON.stringify(dataToSave, null, 2) +
                close_delim;

            const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${driveFileId.current}?uploadType=multipart`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${accessToken.current}`,
                    'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                },
                body: multipartRequestBody
            });

            if (!response.ok) {
                 // Handle token expiration if needed
                 if (response.status === 401) {
                     setError("Сессия истекла. Пожалуйста, войдите снова.");
                     handleSignOut();
                 } else {
                     throw new Error('Не удалось сохранить данные.');
                 }
            }
        } catch (err) {
            console.error("Failed to save to drive:", err);
            // Optionally notify user
        }
    }, 1000), [accessToken.current, driveFileId.current]);

    const handleApiKeySubmit = async (apiKey) => {
        setError(null);
        setAppState(AppState.AUTH_LOADING);
        try {
            const service = new GeminiService(apiKey);
            const connectionTest = await service.testConnection();
            if (!connectionTest.success) {
                throw new Error(connectionTest.error || 'Ключ недействителен.');
            }
            setGeminiService(service);
            const newUserData = { ...userData, apiKey };
            setUserData(newUserData);
            
            // This is a new user, create the file on Drive
            const boundary = '-------314159265358979323846';
            const delimiter = "\r\n--" + boundary + "\r\n";
            const close_delim = "\r\n--" + boundary + "--";
            const metadata = { name: DRIVE_APP_FILE_NAME, mimeType: 'application/json' };
            const multipartRequestBody = delimiter + 'Content-Type: application/json\r\n\r\n' + JSON.stringify(metadata) + delimiter + 'Content-Type: application/json\r\n\r\n' + JSON.stringify(newUserData, null, 2) + close_delim;
            const createResponse = await fetch(`https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${accessToken.current}`, 'Content-Type': 'multipart/related; boundary="' + boundary + '"' },
                body: multipartRequestBody
            });
            const createData = await createResponse.json();
            driveFileId.current = createData.id;

            setAppState(AppState.WELCOME);
        } catch (err) {
            setError(err.message);
            setAppState(AppState.AUTH);
        }
    };

    const handleSignOut = () => {
        // Revoke token
        if (accessToken.current && window.google) {
            window.google.accounts.oauth2.revoke(accessToken.current, () => {});
        }
        setAppState(AppState.AUTH);
        setUserData(null);
        setGeminiService(null);
        setError(null);
        setIsSignedIn(false);
        accessToken.current = null;
        driveFileId.current = null;
    };
    
    // --- State Machine Logic ---
    useEffect(() => {
        if(userData) {
            saveToDrive(userData);
        }
    }, [userData, saveToDrive]);

    const startAssessment = async () => {
        if (!geminiService) return;
        setAppState(AppState.ASSESSMENT_LOADING);
        try {
            const questions = await geminiService.generateAssessmentTest();
            setAssessmentQuestions(questions);
            setAppState(AppState.ASSESSING);
        } catch (err) {
            setError(err.message);
            setAppState(AppState.WELCOME);
        }
    };
    
    const handleTaskComplete = ({ results, task }) => {
        setUserData(prev => {
            if (!prev) return null;

            const today = new Date().toISOString().split('T')[0];
            const newDailyStats = prev.dailyStats.date === today ? { ...prev.dailyStats } : { date: today, completed: 0, correct: 0 };
            newDailyStats.completed += results.length;
            newDailyStats.correct += results.filter(r => r.isCorrect).length;

            const newHistory = [...prev.taskHistory, ...results.map(r => r.isCorrect)].slice(-PROGRESS_HISTORY_LENGTH);
            
            const newVocabProgress = { ...prev.vocabularyProgress };
            let newMistakes = [...prev.recentMistakes];
            
            let wordsFromThisTask = [];
            if (task.wordToLearn) {
                wordsFromThisTask.push(task.wordToLearn);
            }
            results.forEach(r => {
                if (r.wordToLearn) {
                    wordsFromThisTask.push(r.wordToLearn);
                }
            });
            wordsFromThisTask = [...new Set(wordsFromThisTask.map(w => w.toLowerCase().trim()))];

            const newRecentWords = [...new Set([...wordsFromThisTask, ...(prev.recentWordsPracticed || [])])].slice(0, RECENT_WORDS_TO_TRACK);

            results.forEach(r => {
                if(r.wordToLearn) {
                    const word = r.wordToLearn.toLowerCase().trim();
                    if(r.isCorrect) {
                        newVocabProgress[word] = (newVocabProgress[word] || 0) + 1;
                    } else {
                        newVocabProgress[word] = 0; // Reset progress on mistake
                         // Add to recent mistakes if it's a vocabulary type task
                        if(['vocabulary', 'translation-choice', 'spelling-choice', 'word-formation'].includes(task.type)) {
                            const mistakeInfo = { topic: word, details: `Incorrect answer in a '${task.type}' task.` };
                            newMistakes = [mistakeInfo, ...newMistakes.filter(m => m.topic !== word)].slice(0, MISTAKES_TO_REMEMBER);
                        }
                    }
                }
            });
            
             // Track task type history
            const newShortTermTaskTypeHistory = [task.type, ...(prev.shortTermTaskTypeHistory || [])].slice(0, SHORT_TERM_TASK_TYPES_TO_TRACK);
            const newFullTaskTypeHistory = [task.type, ...(prev.fullTaskTypeHistory || [])].slice(0, LONG_TERM_TASK_HISTORY_LENGTH);
            
            return {
                ...prev,
                taskHistory: newHistory,
                dailyStats: newDailyStats,
                feedbackHistory: [], // Clear feedback after it's used
                vocabularyProgress: newVocabProgress,
                recentMistakes: newMistakes,
                shortTermTaskTypeHistory: newShortTermTaskTypeHistory,
                fullTaskTypeHistory: newFullTaskTypeHistory,
                recentWordsPracticed: newRecentWords
            };
        });
    };
    
    const startLevelUpTest = async () => {
        if (!geminiService || !userData?.level) return;
        setAppState(AppState.LEVEL_UP_ASSESSMENT_LOADING);
        try {
            const questions = await geminiService.generateLevelUpTest(userData.level);
            setLevelUpQuestions(questions);
            setAppState(AppState.LEVEL_UP_ASSESSING);
        } catch (err) {
            setError(err.message);
            setAppState(AppState.LEARNING);
        }
    };
    
     const handleLevelUpComplete = (score) => {
        const isSuccess = score >= LEVEL_UP_PASS_PERCENTAGE;
        if (isSuccess && userData?.level) {
            const currentLevelIndex = CEFR_LEVELS_ORDER.indexOf(userData.level);
            const nextLevel = CEFR_LEVELS_ORDER[currentLevelIndex + 1] || CEFR_LEVELS_ORDER[CEFR_LEVELS_ORDER.length - 1];
            setUserData(prev => prev ? { ...prev, level: nextLevel, taskHistory: [] } : null);
        } else {
             setUserData(prev => prev ? { ...prev, taskHistory: [] } : null);
        }
        setAppState(AppState.LEVEL_UP_RESULTS);
    };

    // --- Render logic ---
    const renderContent = () => {
        switch (appState) {
            case AppState.AUTH:
            case AppState.AUTH_LOADING:
                return <AuthScreen 
                            onGoogleSignIn={handleGoogleSignIn}
                            onApiKeySubmit={handleApiKeySubmit}
                            isSignedIn={isSignedIn}
                            userName={userData?.user?.name || tempUser.current?.name || null}
                            error={error}
                            isLoading={appState === AppState.AUTH_LOADING}
                            isGsiLoaded={gsiLoaded}
                        />;
            case AppState.WELCOME:
                return userData && <WelcomeScreen user={userData.user} onStart={startAssessment} />;
            case AppState.ASSESSMENT_LOADING:
                return <div className="min-h-screen flex items-center justify-center"><Loader text="Готовлю тест для определения уровня..." /></div>;
            case AppState.ASSESSING:
                return <Assessment questions={assessmentQuestions} onComplete={handleAssessmentComplete} />;
            case AppState.RESULTS:
                return userData?.level && <ResultsScreen level={userData.level} onStartLearning={() => setAppState(AppState.LEARNING)} />;
            case AppState.LEARNING:
                 return userData && geminiService && (
                    <div className="bg-gray-950 min-h-screen">
                        <Header user={userData.user} onSignOut={handleSignOut} level={userData.level} dailyStats={userData.dailyStats} />
                        <LearningDashboard
                            geminiService={geminiService}
                            userData={userData}
                            onTaskComplete={handleTaskComplete}
                            onStartLevelUpTest={startLevelUpTest}
                            onFeedbackSubmit={(feedback) => setUserData(prev => prev ? { ...prev, feedbackHistory: [...prev.feedbackHistory, feedback] } : null)}
                            onGlobalInstructionsChange={(instructions) => setUserData(prev => prev ? { ...prev, globalInstructions: instructions } : null)}
                        />
                    </div>
                );
            case AppState.LEVEL_UP_ASSESSMENT_LOADING:
                return <div className="min-h-screen flex items-center justify-center"><Loader text="Готовлю тест для повышения уровня..." /></div>;
            case AppState.LEVEL_UP_ASSESSING:
                return <LevelUpAssessment questions={levelUpQuestions} onComplete={handleLevelUpComplete} />;
            case AppState.LEVEL_UP_RESULTS:
                const isSuccess = (userData?.taskHistory.length === 0);
                return <LevelUpResultsScreen isSuccess={isSuccess} newLevel={userData?.level} onContinue={() => setAppState(AppState.LEARNING)} />;
            default:
                return <div className="text-red-500">Error: Unknown application state.</div>;
        }
    };
    
    return <div className="min-h-screen bg-gray-950">{renderContent()}</div>;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>